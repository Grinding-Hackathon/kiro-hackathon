# iOS Mobile App Documentation\n\n## üéØ Overview\n\nThe Offline Blockchain Wallet iOS app is a SwiftUI-based mobile application that enables secure cryptocurrency transactions both online and offline. It supports peer-to-peer transactions via Bluetooth and QR codes, with automatic synchronization when network connectivity is restored.\n\n## üì± Features\n\n- **Secure Wallet Management**: Create and manage cryptocurrency wallets\n- **Offline Transactions**: Send and receive payments without internet connectivity\n- **Bluetooth Communication**: Peer-to-peer transactions via Bluetooth LE\n- **QR Code Integration**: Generate and scan QR codes for payments\n- **Biometric Authentication**: Touch ID / Face ID support\n- **Background Services**: Automatic synchronization and token management\n- **Dark Mode Support**: Adaptive UI for light and dark themes\n\n## üöÄ Quick Start\n\n### Prerequisites\n\n- Xcode 15.0+\n- iOS 15.0+\n- macOS 12.0+ (for development)\n- Apple Developer Account (for device testing)\n\n### Installation\n\n```bash\n# Clone the repository\ngit clone <repository-url>\ncd ios/offline-blockchain-wallet-ios\n\n# Configure the project\n./configure_project.sh\n\n# Resolve Swift Package dependencies\nswift package resolve\n\n# Open in Xcode\nopen offline-blockchain-wallet-ios.xcodeproj\n```\n\n### Build and Run\n\n```bash\n# Build for simulator\nxcodebuild -scheme offline-blockchain-wallet-ios \\\n  -destination 'platform=iOS Simulator,name=iPhone 15,OS=latest' \\\n  build\n\n# Run tests\nswift test\n\n# Build for device\n./scripts/build.sh --device\n```\n\n## üìÅ Project Structure\n\n```\nios/offline-blockchain-wallet-ios/\n‚îú‚îÄ‚îÄ offline-blockchain-wallet-ios/\n‚îÇ   ‚îú‚îÄ‚îÄ Views/                      # SwiftUI Views\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WalletView.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransactionView.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QRScannerView.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QRCodeDisplayView.swift\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SettingsView.swift\n‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/                 # MVVM ViewModels\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WalletViewModel.swift\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransactionViewModel.swift\n‚îÇ   ‚îú‚îÄ‚îÄ Services/                   # Business Logic Services\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NetworkService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CryptographyService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StorageService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BluetoothService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QRCodeService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OfflineTokenService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransactionService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BackupService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DataSyncService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BackgroundTaskManager.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BackgroundServiceCoordinator.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BackgroundBluetoothService.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PushNotificationService.swift\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ QRBluetoothIntegrationService.swift\n‚îÇ   ‚îú‚îÄ‚îÄ Models/                     # Data Models\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OfflineToken.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QRCodeData.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BluetoothModels.swift\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BackgroundServiceTypes.swift\n‚îÇ   ‚îú‚îÄ‚îÄ Utils/                      # Utility Classes\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Constants.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Logger.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandler.swift\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ThemeManager.swift\n‚îÇ   ‚îú‚îÄ‚îÄ Configuration/              # App Configuration\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuildConfiguration.swift\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Debug.xcconfig\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Release.xcconfig\n‚îÇ   ‚îú‚îÄ‚îÄ Models/                     # Core Data Models\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WalletDataModel.xcdatamodeld/\n‚îÇ   ‚îú‚îÄ‚îÄ ContentView.swift           # Main App View\n‚îÇ   ‚îú‚îÄ‚îÄ offline_blockchain_wallet_iosApp.swift  # App Entry Point\n‚îÇ   ‚îú‚îÄ‚îÄ Info.plist                  # App Configuration\n‚îÇ   ‚îî‚îÄ‚îÄ LaunchScreen.storyboard     # Launch Screen\n‚îú‚îÄ‚îÄ Tests/                          # Unit Tests\n‚îÇ   ‚îî‚îÄ‚îÄ OfflineBlockchainWalletTests/\n‚îÇ       ‚îú‚îÄ‚îÄ CryptographyServiceTests.swift\n‚îÇ       ‚îú‚îÄ‚îÄ StorageServiceTests.swift\n‚îÇ       ‚îú‚îÄ‚îÄ BluetoothServiceTests.swift\n‚îÇ       ‚îú‚îÄ‚îÄ QRCodeServiceTests.swift\n‚îÇ       ‚îú‚îÄ‚îÄ OfflineTokenServiceTests.swift\n‚îÇ       ‚îú‚îÄ‚îÄ TransactionServiceTests.swift\n‚îÇ       ‚îú‚îÄ‚îÄ NetworkServiceTests.swift\n‚îÇ       ‚îî‚îÄ‚îÄ WalletViewModelTests.swift\n‚îú‚îÄ‚îÄ Scripts/                        # Build Scripts\n‚îÇ   ‚îú‚îÄ‚îÄ build.sh\n‚îÇ   ‚îú‚îÄ‚îÄ fix_build_issues.sh\n‚îÇ   ‚îú‚îÄ‚îÄ fix_dependencies_safely.sh\n‚îÇ   ‚îî‚îÄ‚îÄ device-testing-automation.sh\n‚îú‚îÄ‚îÄ Package.swift                   # Swift Package Manager\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ XCODE_SETUP.md\n‚îú‚îÄ‚îÄ TROUBLESHOOTING.md\n‚îî‚îÄ‚îÄ configure_project.sh\n```\n\n## üèóÔ∏è Architecture\n\n### MVVM Pattern\n\nThe app follows the Model-View-ViewModel (MVVM) architectural pattern:\n\n```swift\n// Model\nstruct OfflineToken: Codable {\n    let id: String\n    let amount: Double\n    let signature: String\n    let expiresAt: Date\n    var isSpent: Bool\n}\n\n// ViewModel\nclass WalletViewModel: ObservableObject {\n    @Published var balance: Double = 0.0\n    @Published var tokens: [OfflineToken] = []\n    \n    private let walletService: WalletService\n    \n    func refreshBalance() {\n        // Update balance from service\n    }\n}\n\n// View\nstruct WalletView: View {\n    @StateObject private var viewModel = WalletViewModel()\n    \n    var body: some View {\n        VStack {\n            Text(\"Balance: \\(viewModel.balance)\")\n            // UI components\n        }\n        .onAppear {\n            viewModel.refreshBalance()\n        }\n    }\n}\n```\n\n### Service Layer Architecture\n\n```mermaid\ngraph TD\n    A[Views] --> B[ViewModels]\n    B --> C[Services]\n    C --> D[Core Data]\n    C --> E[Keychain]\n    C --> F[Network]\n    C --> G[Bluetooth]\n    C --> H[Cryptography]\n```\n\n## üîß Core Services\n\n### Network Service\n\nHandles all API communication with the backend.\n\n```swift\nclass NetworkService: NetworkServiceProtocol {\n    private let baseURL: String\n    private let session: URLSession\n    \n    func authenticateUser(email: String, password: String) async throws -> AuthResponse {\n        let request = AuthRequest(email: email, password: password)\n        return try await post(\"/auth/login\", body: request)\n    }\n    \n    func getWalletBalance(walletId: String) async throws -> WalletBalanceResponse {\n        return try await get(\"/wallet/balance\")\n    }\n    \n    func purchaseTokens(amount: Double) async throws -> TokenPurchaseResponse {\n        let request = TokenPurchaseRequest(amount: amount)\n        return try await post(\"/wallet/purchase\", body: request)\n    }\n}\n```\n\n### Cryptography Service\n\nProvides cryptographic operations for secure transactions.\n\n```swift\nclass CryptographyService {\n    func generateKeyPair() throws -> (privateKey: SecKey, publicKey: SecKey) {\n        let attributes: [String: Any] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,\n            kSecAttrKeySizeInBits as String: 256\n        ]\n        \n        var publicKey, privateKey: SecKey?\n        let status = SecKeyGeneratePair(attributes as CFDictionary, &publicKey, &privateKey)\n        \n        guard status == errSecSuccess,\n              let pubKey = publicKey,\n              let privKey = privateKey else {\n            throw CryptographyError.keyGenerationFailed\n        }\n        \n        return (privKey, pubKey)\n    }\n    \n    func signData(_ data: Data, with privateKey: SecKey) throws -> Data {\n        var error: Unmanaged<CFError>?\n        guard let signature = SecKeyCreateSignature(\n            privateKey,\n            .ecdsaSignatureMessageX962SHA256,\n            data as CFData,\n            &error\n        ) else {\n            throw CryptographyError.signingFailed\n        }\n        \n        return signature as Data\n    }\n    \n    func verifySignature(_ signature: Data, for data: Data, with publicKey: SecKey) -> Bool {\n        var error: Unmanaged<CFError>?\n        return SecKeyVerifySignature(\n            publicKey,\n            .ecdsaSignatureMessageX962SHA256,\n            data as CFData,\n            signature as CFData,\n            &error\n        )\n    }\n}\n```\n\n### Storage Service\n\nManages local data persistence using Core Data and Keychain.\n\n```swift\nclass StorageService: StorageServiceProtocol {\n    private lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"WalletDataModel\")\n        container.loadPersistentStores { _, error in\n            if let error = error {\n                Logger.shared.error(\"Core Data error: \\(error)\")\n            }\n        }\n        return container\n    }()\n    \n    func saveOfflineTokens(_ tokens: [OfflineToken]) async throws {\n        let context = persistentContainer.viewContext\n        \n        for token in tokens {\n            let entity = OfflineTokenEntity(context: context)\n            entity.id = token.id\n            entity.amount = token.amount\n            entity.signature = token.signature\n            entity.expiresAt = token.expiresAt\n            entity.isSpent = token.isSpent\n        }\n        \n        try context.save()\n    }\n    \n    func loadOfflineTokens() async throws -> [OfflineToken] {\n        let context = persistentContainer.viewContext\n        let request: NSFetchRequest<OfflineTokenEntity> = OfflineTokenEntity.fetchRequest()\n        \n        let entities = try context.fetch(request)\n        return entities.map { entity in\n            OfflineToken(\n                id: entity.id ?? \"\",\n                amount: entity.amount,\n                signature: entity.signature ?? \"\",\n                expiresAt: entity.expiresAt ?? Date(),\n                isSpent: entity.isSpent\n            )\n        }\n    }\n    \n    func storePrivateKey(_ key: SecKey, for identifier: String) throws {\n        let keychain = Keychain(service: \"com.wallet.app\")\n        let keyData = try keyToData(key)\n        try keychain.set(keyData, key: \"privateKey_\\(identifier)\")\n    }\n}\n```\n\n### Bluetooth Service\n\nEnables peer-to-peer communication via Bluetooth LE.\n\n```swift\nclass BluetoothService: NSObject, BluetoothServiceProtocol {\n    private var centralManager: CBCentralManager!\n    private var peripheralManager: CBPeripheralManager!\n    private let serviceUUID = CBUUID(string: \"12345678-1234-1234-1234-123456789ABC\")\n    \n    func startAdvertising(walletInfo: WalletInfo) throws {\n        let advertisementData: [String: Any] = [\n            CBAdvertisementDataServiceUUIDsKey: [serviceUUID],\n            CBAdvertisementDataLocalNameKey: \"Wallet_\\(walletInfo.walletId.prefix(8))\"\n        ]\n        \n        peripheralManager.startAdvertising(advertisementData)\n        Logger.shared.info(\"Started advertising wallet: \\(walletInfo.walletId)\")\n    }\n    \n    func scanForDevices() async throws -> [BluetoothDevice] {\n        return await withCheckedThrowingContinuation { continuation in\n            discoveredDevices = []\n            scanContinuation = continuation\n            \n            centralManager.scanForPeripherals(\n                withServices: [serviceUUID],\n                options: [CBCentralManagerScanOptionAllowDuplicatesKey: false]\n            )\n            \n            // Timeout after 10 seconds\n            DispatchQueue.main.asyncAfter(deadline: .now() + 10) {\n                self.centralManager.stopScan()\n                continuation.resume(returning: self.discoveredDevices)\n            }\n        }\n    }\n    \n    func sendData(_ data: Data, to connection: BluetoothConnection) async throws {\n        guard let peripheral = connection.peripheral,\n              let characteristic = connection.characteristic else {\n            throw BluetoothError.invalidConnection\n        }\n        \n        peripheral.writeValue(\n            data,\n            for: characteristic,\n            type: .withResponse\n        )\n    }\n}\n```\n\n### QR Code Service\n\nHandles QR code generation and scanning for payments.\n\n```swift\nclass QRCodeService {\n    func generateQRCode(for paymentRequest: QRCodePaymentRequest) throws -> UIImage {\n        let encoder = JSONEncoder()\n        let jsonData = try encoder.encode(paymentRequest)\n        \n        guard let filter = CIFilter(name: \"CIQRCodeGenerator\") else {\n            throw QRCodeError.generationFailed\n        }\n        \n        filter.setValue(jsonData, forKey: \"inputMessage\")\n        filter.setValue(\"M\", forKey: \"inputCorrectionLevel\")\n        \n        guard let outputImage = filter.outputImage else {\n            throw QRCodeError.generationFailed\n        }\n        \n        let transform = CGAffineTransform(scaleX: 10, y: 10)\n        let scaledImage = outputImage.transformed(by: transform)\n        \n        let context = CIContext()\n        guard let cgImage = context.createCGImage(scaledImage, from: scaledImage.extent) else {\n            throw QRCodeError.generationFailed\n        }\n        \n        return UIImage(cgImage: cgImage)\n    }\n    \n    func parseQRCode(_ string: String) throws -> QRCodePaymentRequest {\n        guard let data = string.data(using: .utf8) else {\n            throw QRCodeError.invalidFormat\n        }\n        \n        let decoder = JSONDecoder()\n        return try decoder.decode(QRCodePaymentRequest.self, from: data)\n    }\n    \n    func validateQRCode(_ paymentRequest: QRCodePaymentRequest) -> QRCodeValidationResult {\n        var errors: [String] = []\n        \n        // Validate timestamp (not older than 5 minutes)\n        if Date().timeIntervalSince(paymentRequest.timestamp) > 300 {\n            errors.append(\"QR code has expired\")\n        }\n        \n        // Validate amount\n        if paymentRequest.amount <= 0 {\n            errors.append(\"Invalid payment amount\")\n        }\n        \n        // Validate wallet ID format\n        if paymentRequest.walletId.isEmpty {\n            errors.append(\"Invalid wallet ID\")\n        }\n        \n        return QRCodeValidationResult(\n            isValid: errors.isEmpty,\n            errors: errors\n        )\n    }\n}\n```\n\n### Offline Token Service\n\nManages offline token operations and validation.\n\n```swift\nclass OfflineTokenService: OfflineTokenServiceProtocol {\n    private let cryptographyService: CryptographyService\n    private let storageService: StorageService\n    \n    func validateToken(_ token: OfflineToken) -> Bool {\n        // Check if token is expired\n        if token.expiresAt < Date() {\n            return false\n        }\n        \n        // Check if token is already spent\n        if token.isSpent {\n            return false\n        }\n        \n        // Verify signature\n        return verifyTokenSignature(token)\n    }\n    \n    func divideToken(_ token: OfflineToken, amount: Double) throws -> TokenDivisionResult {\n        guard validateToken(token) else {\n            throw TokenError.invalidToken\n        }\n        \n        guard amount > 0 && amount < token.amount else {\n            throw TokenError.invalidAmount\n        }\n        \n        let paymentToken = OfflineToken(\n            id: UUID().uuidString,\n            amount: amount,\n            signature: try generateTokenSignature(amount: amount),\n            expiresAt: token.expiresAt,\n            isSpent: false\n        )\n        \n        let changeAmount = token.amount - amount\n        let changeToken = OfflineToken(\n            id: UUID().uuidString,\n            amount: changeAmount,\n            signature: try generateTokenSignature(amount: changeAmount),\n            expiresAt: token.expiresAt,\n            isSpent: false\n        )\n        \n        // Mark original token as spent\n        try markTokenAsSpent(token.id)\n        \n        return TokenDivisionResult(\n            paymentToken: paymentToken,\n            changeToken: changeToken\n        )\n    }\n    \n    func calculateOfflineBalance() async throws -> Double {\n        let tokens = try await storageService.loadOfflineTokens()\n        return tokens\n            .filter { !$0.isSpent && $0.expiresAt > Date() }\n            .reduce(0) { $0 + $1.amount }\n    }\n}\n```\n\n## üì± User Interface\n\n### Main Wallet View\n\n```swift\nstruct WalletView: View {\n    @StateObject private var walletViewModel: WalletViewModel\n    @State private var showingSettings = false\n    @State private var showingTransactionView = false\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    balanceSection\n                    quickActionsSection\n                    recentTransactionsSection\n                }\n                .padding()\n            }\n            .navigationTitle(\"Wallet\")\n            .navigationBarTitleDisplayMode(.large)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: {\n                        showingSettings = true\n                    }) {\n                        Image(systemName: \"gear\")\n                    }\n                }\n            }\n            .sheet(isPresented: $showingSettings) {\n                SettingsView()\n            }\n            .sheet(isPresented: $showingTransactionView) {\n                TransactionView()\n            }\n        }\n    }\n    \n    private var balanceSection: some View {\n        VStack(spacing: 16) {\n            HStack {\n                VStack(alignment: .leading) {\n                    Text(\"Total Balance\")\n                        .font(.headline)\n                        .foregroundColor(.secondary)\n                    \n                    HStack(alignment: .firstTextBaseline, spacing: 4) {\n                        Text(\"$\")\n                            .font(.title2)\n                            .foregroundColor(.primary)\n                        Text(String(format: \"%.2f\", walletViewModel.totalBalance))\n                            .font(.system(size: 36, weight: .bold, design: .rounded))\n                            .foregroundColor(.primary)\n                            .contentTransition(.numericText())\n                    }\n                }\n                Spacer()\n                \n                VStack {\n                    Image(systemName: walletViewModel.isOnline ? \"wifi\" : \"wifi.slash\")\n                        .foregroundColor(walletViewModel.isOnline ? .green : .orange)\n                    Text(walletViewModel.isOnline ? \"Online\" : \"Offline\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            HStack(spacing: 20) {\n                BalanceCard(\n                    title: \"Blockchain\",\n                    amount: walletViewModel.blockchainBalance,\n                    color: .blue\n                )\n                \n                BalanceCard(\n                    title: \"Offline\",\n                    amount: walletViewModel.offlineBalance,\n                    color: .green\n                )\n            }\n        }\n        .padding()\n        .background(Color.adaptiveCardBackground)\n        .cornerRadius(16)\n    }\n    \n    private var quickActionsSection: some View {\n        HStack(spacing: 16) {\n            QuickActionButton(\n                title: \"Send\",\n                icon: \"arrow.up.circle.fill\",\n                color: .red\n            ) {\n                showingTransactionView = true\n            }\n            \n            QuickActionButton(\n                title: \"Receive\",\n                icon: \"arrow.down.circle.fill\",\n                color: .green\n            ) {\n                // Show receive view\n            }\n            \n            QuickActionButton(\n                title: \"Purchase\",\n                icon: \"plus.circle.fill\",\n                color: .blue\n            ) {\n                // Show purchase view\n            }\n            \n            QuickActionButton(\n                title: \"Scan\",\n                icon: \"qrcode.viewfinder\",\n                color: .purple\n            ) {\n                // Show QR scanner\n            }\n        }\n    }\n}\n```\n\n### Transaction View\n\n```swift\nstruct TransactionView: View {\n    @StateObject private var transactionViewModel = TransactionViewModel()\n    @Environment(\\.dismiss) private var dismiss\n    @State private var selectedTab = 0\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Picker(\"Transaction Type\", selection: $selectedTab) {\n                    Text(\"Send\").tag(0)\n                    Text(\"Request\").tag(1)\n                }\n                .pickerStyle(SegmentedPickerStyle())\n                .padding()\n                \n                TabView(selection: $selectedTab) {\n                    SendTransactionView(viewModel: transactionViewModel)\n                        .tag(0)\n                    \n                    RequestTransactionView(viewModel: transactionViewModel)\n                        .tag(1)\n                }\n                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))\n            }\n            .navigationTitle(\"Transactions\")\n            .toolbar {\n                ToolbarItem(placement: .topBarLeading) {\n                    Button(\"Close\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct SendTransactionView: View {\n    @ObservedObject var viewModel: TransactionViewModel\n    @State private var showingQRScanner = false\n    @State private var showingBluetoothDevices = false\n    \n    var body: some View {\n        VStack(spacing: 24) {\n            // Amount input\n            VStack(alignment: .leading, spacing: 8) {\n                Text(\"Amount\")\n                    .font(.headline)\n                \n                HStack {\n                    Text(\"$\")\n                        .font(.title2)\n                        .foregroundColor(.secondary)\n                    \n                    TextField(\"0.00\", text: $transactionViewModel.amount)\n                        .textFieldStyle(RoundedBorderTextFieldStyle())\n                        .keyboardType(.decimalPad)\n                        .font(.system(size: 24, weight: .semibold, design: .rounded))\n                        .multilineTextAlignment(.center)\n                }\n            }\n            \n            // Recipient input\n            VStack(alignment: .leading, spacing: 8) {\n                Text(\"Recipient\")\n                    .font(.headline)\n                \n                HStack {\n                    TextField(\"Wallet address or scan QR\", text: $viewModel.recipientAddress)\n                        .textFieldStyle(RoundedBorderTextFieldStyle())\n                    \n                    Button(action: {\n                        showingQRScanner = true\n                    }) {\n                        Image(systemName: \"qrcode.viewfinder\")\n                            .font(.title2)\n                    }\n                }\n            }\n            \n            // Send methods\n            VStack(alignment: .leading, spacing: 12) {\n                Text(\"Send Method\")\n                    .font(.headline)\n                \n                HStack(spacing: 16) {\n                    SendMethodButton(\n                        title: \"QR Code\",\n                        icon: \"qrcode\",\n                        isSelected: viewModel.selectedMethod == .qrCode\n                    ) {\n                        viewModel.selectedMethod = .qrCode\n                    }\n                    \n                    SendMethodButton(\n                        title: \"Bluetooth\",\n                        icon: \"bluetooth\",\n                        isSelected: viewModel.selectedMethod == .bluetooth\n                    ) {\n                        viewModel.selectedMethod = .bluetooth\n                        showingBluetoothDevices = true\n                    }\n                    \n                    SendMethodButton(\n                        title: \"Online\",\n                        icon: \"wifi\",\n                        isSelected: viewModel.selectedMethod == .online\n                    ) {\n                        viewModel.selectedMethod = .online\n                    }\n                }\n            }\n            \n            Spacer()\n            \n            // Send button\n            Button(action: {\n                Task {\n                    await viewModel.sendTransaction()\n                }\n            }) {\n                HStack {\n                    if viewModel.isProcessing {\n                        ProgressView()\n                            .progressViewStyle(CircularProgressViewStyle(tint: .white))\n                            .scaleEffect(0.8)\n                    }\n                    \n                    Text(viewModel.isProcessing ? \"Processing...\" : \"Send Payment\")\n                        .font(.headline)\n                        .foregroundColor(.white)\n                }\n                .frame(maxWidth: .infinity)\n                .padding()\n                .background(viewModel.canSend ? Color.blue : Color.gray)\n                .cornerRadius(12)\n            }\n            .disabled(!viewModel.canSend || viewModel.isProcessing)\n        }\n        .padding()\n        .sheet(isPresented: $showingQRScanner) {\n            QRScannerView { result in\n                viewModel.recipientAddress = result\n                showingQRScanner = false\n            }\n        }\n        .sheet(isPresented: $showingBluetoothDevices) {\n            BluetoothDeviceListView(viewModel: viewModel)\n        }\n    }\n}\n```\n\n## üîí Security Implementation\n\n### Biometric Authentication\n\n```swift\nimport LocalAuthentication\n\nclass BiometricAuthService {\n    func authenticateUser() async throws -> Bool {\n        let context = LAContext()\n        var error: NSError?\n        \n        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n            throw BiometricError.notAvailable\n        }\n        \n        let reason = \"Authenticate to access your wallet\"\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.evaluatePolicy(\n                .deviceOwnerAuthenticationWithBiometrics,\n                localizedReason: reason\n            ) { success, error in\n                if let error = error {\n                    continuation.resume(throwing: error)\n                } else {\n                    continuation.resume(returning: success)\n                }\n            }\n        }\n    }\n}\n```\n\n### Keychain Storage\n\n```swift\nimport KeychainAccess\n\nclass SecureStorage {\n    private let keychain = Keychain(service: \"com.wallet.app\")\n        .accessibility(.whenUnlockedThisDeviceOnly)\n    \n    func storePrivateKey(_ key: Data, for identifier: String) throws {\n        try keychain.set(key, key: \"privateKey_\\(identifier)\")\n    }\n    \n    func retrievePrivateKey(for identifier: String) throws -> Data? {\n        return try keychain.getData(\"privateKey_\\(identifier)\")\n    }\n    \n    func storeAuthToken(_ token: String) throws {\n        try keychain.set(token, key: \"authToken\")\n    }\n    \n    func retrieveAuthToken() throws -> String? {\n        return try keychain.get(\"authToken\")\n    }\n    \n    func clearAll() throws {\n        try keychain.removeAll()\n    }\n}\n```\n\n## üß™ Testing\n\n### Unit Tests\n\n```swift\nimport XCTest\n@testable import offline_blockchain_wallet_ios\n\nclass CryptographyServiceTests: XCTestCase {\n    var cryptographyService: CryptographyService!\n    \n    override func setUp() {\n        super.setUp()\n        cryptographyService = CryptographyService()\n    }\n    \n    func testKeyGeneration() throws {\n        let (privateKey, publicKey) = try cryptographyService.generateKeyPair()\n        \n        XCTAssertNotNil(privateKey)\n        XCTAssertNotNil(publicKey)\n    }\n    \n    func testSignatureCreationAndVerification() throws {\n        let (privateKey, publicKey) = try cryptographyService.generateKeyPair()\n        let testData = \"Hello, World!\".data(using: .utf8)!\n        \n        let signature = try cryptographyService.signData(testData, with: privateKey)\n        let isValid = cryptographyService.verifySignature(signature, for: testData, with: publicKey)\n        \n        XCTAssertTrue(isValid)\n    }\n    \n    func testInvalidSignatureRejection() throws {\n        let (privateKey1, _) = try cryptographyService.generateKeyPair()\n        let (_, publicKey2) = try cryptographyService.generateKeyPair()\n        let testData = \"Hello, World!\".data(using: .utf8)!\n        \n        let signature = try cryptographyService.signData(testData, with: privateKey1)\n        let isValid = cryptographyService.verifySignature(signature, for: testData, with: publicKey2)\n        \n        XCTAssertFalse(isValid)\n    }\n}\n```\n\n### Integration Tests\n\n```swift\nclass NetworkServiceIntegrationTests: XCTestCase {\n    var networkService: NetworkService!\n    \n    override func setUp() {\n        super.setUp()\n        let config = URLSessionConfiguration.default\n        config.protocolClasses = [MockURLProtocol.self]\n        let session = URLSession(configuration: config)\n        networkService = NetworkService(session: session)\n    }\n    \n    func testUserAuthentication() async throws {\n        // Mock successful authentication response\n        MockURLProtocol.mockResponse = AuthResponse(\n            user: User(id: \"123\", username: \"test\", email: \"test@example.com\"),\n            tokens: Tokens(accessToken: \"token123\", refreshToken: \"refresh123\")\n        )\n        \n        let response = try await networkService.authenticateUser(\n            email: \"test@example.com\",\n            password: \"password123\"\n        )\n        \n        XCTAssertEqual(response.user.email, \"test@example.com\")\n        XCTAssertFalse(response.tokens.accessToken.isEmpty)\n    }\n}\n```\n\n### UI Tests\n\n```swift\nclass WalletUITests: XCTestCase {\n    var app: XCUIApplication!\n    \n    override func setUp() {\n        super.setUp()\n        app = XCUIApplication()\n        app.launch()\n    }\n    \n    func testWalletBalanceDisplay() {\n        let balanceLabel = app.staticTexts[\"Total Balance\"]\n        XCTAssertTrue(balanceLabel.exists)\n        \n        let balanceAmount = app.staticTexts.matching(NSPredicate(format: \"label CONTAINS '$'\")).firstMatch\n        XCTAssertTrue(balanceAmount.exists)\n    }\n    \n    func testSendTransactionFlow() {\n        app.buttons[\"Send\"].tap()\n        \n        let amountField = app.textFields[\"0.00\"]\n        amountField.tap()\n        amountField.typeText(\"25.00\")\n        \n        let recipientField = app.textFields[\"Wallet address or scan QR\"]\n        recipientField.tap()\n        recipientField.typeText(\"0x742d35Cc6634C0532925a3b8D404d3aAB451e9c\")\n        \n        app.buttons[\"Send Payment\"].tap()\n        \n        // Verify transaction confirmation\n        let confirmationAlert = app.alerts[\"Confirm Transaction\"]\n        XCTAssertTrue(confirmationAlert.waitForExistence(timeout: 5))\n    }\n}\n```\n\n## üîß Configuration\n\n### Build Configurations\n\n#### Debug Configuration (Debug.xcconfig)\n```\nAPI_BASE_URL = https://dev-api.wallet.com\nLOG_LEVEL = DEBUG\nENABLE_MOCK_SERVICES = YES\nBLUETOOTH_TIMEOUT = 30\nQR_CODE_TIMEOUT = 300\nTOKEN_EXPIRY_DAYS = 30\n```\n\n#### Release Configuration (Release.xcconfig)\n```\nAPI_BASE_URL = https://api.wallet.com\nLOG_LEVEL = ERROR\nENABLE_MOCK_SERVICES = NO\nBLUETOOTH_TIMEOUT = 10\nQR_CODE_TIMEOUT = 60\nTOKEN_EXPIRY_DAYS = 7\n```\n\n### Info.plist Configuration\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>CFBundleDisplayName</key>\n    <string>Offline Wallet</string>\n    <key>CFBundleIdentifier</key>\n    <string>com.company.offline-blockchain-wallet</string>\n    <key>CFBundleVersion</key>\n    <string>1.0.0</string>\n    \n    <!-- Camera permission for QR scanning -->\n    <key>NSCameraUsageDescription</key>\n    <string>This app needs camera access to scan QR codes for payments</string>\n    \n    <!-- Bluetooth permission -->\n    <key>NSBluetoothAlwaysUsageDescription</key>\n    <string>This app uses Bluetooth to enable offline peer-to-peer transactions</string>\n    <key>NSBluetoothPeripheralUsageDescription</key>\n    <string>This app uses Bluetooth to enable offline peer-to-peer transactions</string>\n    \n    <!-- Face ID permission -->\n    <key>NSFaceIDUsageDescription</key>\n    <string>Use Face ID to authenticate and access your wallet</string>\n    \n    <!-- Background modes -->\n    <key>UIBackgroundModes</key>\n    <array>\n        <string>bluetooth-central</string>\n        <string>bluetooth-peripheral</string>\n        <string>background-processing</string>\n    </array>\n    \n    <!-- App Transport Security -->\n    <key>NSAppTransportSecurity</key>\n    <dict>\n        <key>NSAllowsArbitraryLoads</key>\n        <false/>\n        <key>NSExceptionDomains</key>\n        <dict>\n            <key>api.wallet.com</key>\n            <dict>\n                <key>NSExceptionRequiresForwardSecrecy</key>\n                <false/>\n                <key>NSExceptionMinimumTLSVersion</key>\n                <string>TLSv1.2</string>\n            </dict>\n        </dict>\n    </dict>\n</dict>\n</plist>\n```\n\n## üöÄ Deployment\n\n### App Store Deployment\n\n#### 1. Prepare for Release\n\n```bash\n# Update version and build number\n./scripts/update-version.sh 1.0.0\n\n# Switch to release configuration\nxed . # Open in Xcode\n# Product -> Scheme -> Edit Scheme -> Run -> Build Configuration -> Release\n```\n\n#### 2. Archive and Export\n\n```bash\n# Archive for App Store\nxcodebuild archive \\\n  -scheme offline-blockchain-wallet-ios \\\n  -configuration Release \\\n  -destination generic/platform=iOS \\\n  -archivePath build/offline-blockchain-wallet-ios.xcarchive\n\n# Export for App Store\nxcodebuild -exportArchive \\\n  -archivePath build/offline-blockchain-wallet-ios.xcarchive \\\n  -exportPath build/AppStore \\\n  -exportOptionsPlist ExportOptions.plist\n```\n\n#### 3. Upload to App Store Connect\n\n```bash\n# Upload using Transporter or altool\nxcrun altool --upload-app \\\n  -f build/AppStore/offline-blockchain-wallet-ios.ipa \\\n  -u your-apple-id@example.com \\\n  -p @keychain:AC_PASSWORD\n```\n\n### TestFlight Distribution\n\n```bash\n# Export for TestFlight\nxcodebuild -exportArchive \\\n  -archivePath build/offline-blockchain-wallet-ios.xcarchive \\\n  -exportPath build/TestFlight \\\n  -exportOptionsPlist TestFlightExportOptions.plist\n\n# Upload to TestFlight\nxcrun altool --upload-app \\\n  -f build/TestFlight/offline-blockchain-wallet-ios.ipa \\\n  -u your-apple-id@example.com \\\n  -p @keychain:AC_PASSWORD\n```\n\n## üîç Troubleshooting\n\n### Common Build Issues\n\n#### Dependency Resolution\n```bash\n# Clear Swift Package Manager cache\nrm -rf ~/Library/Caches/org.swift.swiftpm\nrm -rf .build\n\n# Reset packages\nswift package reset\nswift package resolve\n```\n\n#### Code Signing Issues\n```bash\n# Check provisioning profiles\nsecurity find-identity -v -p codesigning\n\n# Clean derived data\nrm -rf ~/Library/Developer/Xcode/DerivedData\n\n# Fix signing issues\n./scripts/fix_build_issues.sh\n```\n\n### Runtime Issues\n\n#### Bluetooth Not Working\n```swift\n// Check Bluetooth permissions\nif CBCentralManager.authorization != .allowedAlways {\n    // Request permissions in Info.plist\n}\n\n// Reset Bluetooth state\nbluetoothService.reset()\n```\n\n#### Keychain Access Issues\n```swift\n// Clear keychain data\nlet keychain = Keychain(service: \"com.wallet.app\")\ntry keychain.removeAll()\n\n// Check keychain accessibility\nlet accessibility = keychain.accessibility\nprint(\"Keychain accessibility: \\(accessibility)\")\n```\n\n#### Core Data Issues\n```swift\n// Reset Core Data store\nlet storeURL = persistentContainer.persistentStoreDescriptions.first?.url\nif let url = storeURL {\n    try persistentContainer.persistentStoreCoordinator.destroyPersistentStore(\n        at: url,\n        ofType: NSSQLiteStoreType,\n        options: nil\n    )\n}\n```\n\n### Performance Issues\n\n#### Memory Leaks\n```swift\n// Use weak references in closures\nservice.performOperation { [weak self] result in\n    self?.handleResult(result)\n}\n\n// Properly dispose of observers\ndeinit {\n    NotificationCenter.default.removeObserver(self)\n}\n```\n\n#### Battery Usage\n```swift\n// Optimize Bluetooth scanning\nfunc optimizeBluetooth() {\n    // Scan only when needed\n    centralManager.scanForPeripherals(\n        withServices: [serviceUUID],\n        options: [CBCentralManagerScanOptionAllowDuplicatesKey: false]\n    )\n    \n    // Stop scanning after timeout\n    DispatchQueue.main.asyncAfter(deadline: .now() + 10) {\n        self.centralManager.stopScan()\n    }\n}\n```\n\n## üìö Additional Resources\n\n### Documentation\n- [Apple Developer Documentation](https://developer.apple.com/documentation/)\n- [SwiftUI Documentation](https://developer.apple.com/documentation/swiftui)\n- [Core Data Documentation](https://developer.apple.com/documentation/coredata)\n- [CryptoKit Documentation](https://developer.apple.com/documentation/cryptokit)\n\n### Sample Code\n- [Bluetooth LE Implementation](./BLUETOOTH_IMPLEMENTATION_SUMMARY.md)\n- [Cryptography Service](./CRYPTOGRAPHY_IMPLEMENTATION_SUMMARY.md)\n- [Background Services](./BACKGROUND_SERVICES_IMPLEMENTATION.md)\n- [Transaction Service](./TRANSACTION_SERVICE_IMPLEMENTATION.md)\n\n### Testing Resources\n- [Device Testing Matrix](./DEVICE_TESTING_MATRIX.md)\n- [Xcode Setup Guide](./XCODE_SETUP.md)\n- [Troubleshooting Guide](./TROUBLESHOOTING.md)\n\n---\n\n*This documentation is maintained by the iOS development team and updated with each release. For questions or contributions, please contact the development team.*\n"